/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountsClient {
    register(command: RegisterCommand): Observable<FileResponse>;
    login(command: LoginAccountCommand): Observable<FileResponse>;
    loginWith2fa(command: LoginWith2faCommand): Observable<FileResponse>;
    externalLogin(provider: string | null, returnUrl?: string | null | undefined): Observable<FileResponse>;
    externalLoginCallback(returnUrl?: string | null | undefined, remoteError?: string | null | undefined): Observable<FileResponse>;
    updateProfile(command: UpdateProfileCommand): Observable<FileResponse>;
    getUserInfor(): Observable<UserInforVm>;
    changePassword(command: ChangePasswordCommand): Observable<FileResponse>;
    forgotPassword(command: ForgotPasswordCommand): Observable<FileResponse>;
    resetPassword(command: ResetPasswordCommand): Observable<FileResponse>;
    setPassword(command: SetPasswordCommand): Observable<FileResponse>;
    getSharedKeyAndQrCodeUri(): Observable<SharedKeyAndQrCodeUriVm>;
    enableAuthenticator(command: EnableAuthenticatorCommand): Observable<FileResponse>;
    reset2fa(command: Reset2faCommand): Observable<FileResponse>;
    resetRecoveryCode(command: ResetRecoveryCodeCommand): Observable<FileResponse>;
    disable2fa(command: Disable2faCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountsClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    register(command: RegisterCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    login(command: LoginAccountCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    loginWith2fa(command: LoginWith2faCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/LoginWith2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLoginWith2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginWith2fa(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processLoginWith2fa(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    externalLogin(provider: string | null, returnUrl?: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ExternalLogin/{provider}?";
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    externalLoginCallback(returnUrl?: string | null | undefined, remoteError?: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ExternalLoginCallback?";
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "ReturnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        if (remoteError !== undefined && remoteError !== null)
            url_ += "RemoteError=" + encodeURIComponent("" + remoteError) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processExternalLoginCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLoginCallback(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLoginCallback(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateProfile(command: UpdateProfileCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getUserInfor(): Observable<UserInforVm> {
        let url_ = this.baseUrl + "/api/Accounts/GetUserInfor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserInfor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfor(<any>response_);
                } catch (e) {
                    return <Observable<UserInforVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInforVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfor(response: HttpResponseBase): Observable<UserInforVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserInforVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInforVm>(<any>null);
    }

    changePassword(command: ChangePasswordCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    forgotPassword(command: ForgotPasswordCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    resetPassword(command: ResetPasswordCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    setPassword(command: SetPasswordCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getSharedKeyAndQrCodeUri(): Observable<SharedKeyAndQrCodeUriVm> {
        let url_ = this.baseUrl + "/api/Accounts/GetSharedKeyAndQrCodeUri";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSharedKeyAndQrCodeUri(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSharedKeyAndQrCodeUri(<any>response_);
                } catch (e) {
                    return <Observable<SharedKeyAndQrCodeUriVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<SharedKeyAndQrCodeUriVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetSharedKeyAndQrCodeUri(response: HttpResponseBase): Observable<SharedKeyAndQrCodeUriVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SharedKeyAndQrCodeUriVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SharedKeyAndQrCodeUriVm>(<any>null);
    }

    enableAuthenticator(command: EnableAuthenticatorCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/EnableAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processEnableAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEnableAuthenticator(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    reset2fa(command: Reset2faCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/Reset2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processReset2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReset2fa(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processReset2fa(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    resetRecoveryCode(command: ResetRecoveryCodeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/ResetRecoveryCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetRecoveryCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetRecoveryCode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processResetRecoveryCode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    disable2fa(command: Disable2faCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Accounts/Disable2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDisable2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable2fa(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDisable2fa(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IActionsClient {
    getAll(method?: string | null | undefined, apiResourceId?: string | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfControllerActionDto>;
    upsert(command: UpsertControllerActionCommand): Observable<string>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfControllerActionOptionDto>;
    get(id: string | null): Observable<ControllerActionDetailVm>;
    delete(id: string | null): Observable<FileResponse>;
    sync(command: SyncControllerActionCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionsClient implements IActionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(method?: string | null | undefined, apiResourceId?: string | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfControllerActionDto> {
        let url_ = this.baseUrl + "/api/Actions?";
        if (method !== undefined && method !== null)
            url_ += "Method=" + encodeURIComponent("" + method) + "&";
        if (apiResourceId !== undefined && apiResourceId !== null)
            url_ += "ApiResourceId=" + encodeURIComponent("" + apiResourceId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfControllerActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfControllerActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfControllerActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfControllerActionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfControllerActionDto>(<any>null);
    }

    upsert(command: UpsertControllerActionCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfControllerActionOptionDto> {
        let url_ = this.baseUrl + "/api/Actions/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfControllerActionOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfControllerActionOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfControllerActionOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfControllerActionOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfControllerActionOptionDto>(<any>null);
    }

    get(id: string | null): Observable<ControllerActionDetailVm> {
        let url_ = this.baseUrl + "/api/Actions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ControllerActionDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ControllerActionDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ControllerActionDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ControllerActionDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ControllerActionDetailVm>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Actions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    sync(command: SyncControllerActionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Actions/Sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IApiResourcesClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfApiResourceDto>;
    upsert(command: UpsertApiResourceCommand): Observable<FileResponse>;
    getOptions(): Observable<ApiResourceOptionDto[]>;
    get(id: string | null): Observable<ApiResourceDetailVm>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ApiResourcesClient implements IApiResourcesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfApiResourceDto> {
        let url_ = this.baseUrl + "/api/ApiResources?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfApiResourceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfApiResourceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfApiResourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfApiResourceDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfApiResourceDto>(<any>null);
    }

    upsert(command: UpsertApiResourceCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ApiResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(): Observable<ApiResourceOptionDto[]> {
        let url_ = this.baseUrl + "/api/ApiResources/GetOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<ApiResourceOptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResourceOptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<ApiResourceOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ApiResourceOptionDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResourceOptionDto[]>(<any>null);
    }

    get(id: string | null): Observable<ApiResourceDetailVm> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResourceDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResourceDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApiResourceDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ApiResourceDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResourceDetailVm>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IArticlesClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfArticleDto>;
    create(command: CreateArticleCommand): Observable<FileResponse>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfArticleOptionDto>;
    get(id: string | null): Observable<ArticleDetailVm>;
    update(id: string | null, command: UpdateArticleCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ArticlesClient implements IArticlesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfArticleDto> {
        let url_ = this.baseUrl + "/api/Articles?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfArticleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfArticleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfArticleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfArticleDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfArticleDto>(<any>null);
    }

    create(command: CreateArticleCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfArticleOptionDto> {
        let url_ = this.baseUrl + "/api/Articles/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfArticleOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfArticleOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfArticleOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfArticleOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfArticleOptionDto>(<any>null);
    }

    get(id: string | null): Observable<ArticleDetailVm> {
        let url_ = this.baseUrl + "/api/Articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ArticleDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ArticleDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ArticleDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ArticleDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ArticleDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateArticleCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICashBooksClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfCashBookDto>;
    create(command: CreateCashBookCommand): Observable<FileResponse>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfCashBookOptionDto>;
    get(id: string | null): Observable<CashBookDetailVm>;
    update(id: string | null, command: UpdateCashBookCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CashBooksClient implements ICashBooksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfCashBookDto> {
        let url_ = this.baseUrl + "/api/CashBooks?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfCashBookDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfCashBookDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfCashBookDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfCashBookDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfCashBookDto>(<any>null);
    }

    create(command: CreateCashBookCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CashBooks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfCashBookOptionDto> {
        let url_ = this.baseUrl + "/api/CashBooks/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfCashBookOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfCashBookOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfCashBookOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfCashBookOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfCashBookOptionDto>(<any>null);
    }

    get(id: string | null): Observable<CashBookDetailVm> {
        let url_ = this.baseUrl + "/api/CashBooks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CashBookDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashBookDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CashBookDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CashBookDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashBookDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateCashBookCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CashBooks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CashBooks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IFilesClient {
    getAll(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfFileDto>;
    get(id: string | null): Observable<FileDetailVm>;
    downloadFile(id: string | null): Observable<FileResponse>;
    upload(folder: string | null, files?: FileParameter[] | null | undefined): Observable<UploadFileResponse[]>;
}

@Injectable({
    providedIn: 'root'
})
export class FilesClient implements IFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfFileDto> {
        let url_ = this.baseUrl + "/api/Files?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfFileDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfFileDto>(<any>null);
    }

    get(id: string | null): Observable<FileDetailVm> {
        let url_ = this.baseUrl + "/api/Files/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = FileDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDetailVm>(<any>null);
    }

    downloadFile(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Files/DownloadFile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    upload(folder: string | null, files?: FileParameter[] | null | undefined): Observable<UploadFileResponse[]> {
        let url_ = this.baseUrl + "/api/Files/{folder}";
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files"));

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<UploadFileResponse[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadFileResponse[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<UploadFileResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UploadFileResponse.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadFileResponse[]>(<any>null);
    }
}

export interface IGroupPermissionsClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfGroupPermissionDto>;
    upsert(command: UpsertGroupPermissionCommand): Observable<FileResponse>;
    getOptions(): Observable<GroupPermissionOptionDto[]>;
    get(id: string | null): Observable<GroupPermissionDetailVm>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class GroupPermissionsClient implements IGroupPermissionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfGroupPermissionDto> {
        let url_ = this.baseUrl + "/api/GroupPermissions?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfGroupPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfGroupPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfGroupPermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfGroupPermissionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfGroupPermissionDto>(<any>null);
    }

    upsert(command: UpsertGroupPermissionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/GroupPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(): Observable<GroupPermissionOptionDto[]> {
        let url_ = this.baseUrl + "/api/GroupPermissions/GetOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<GroupPermissionOptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupPermissionOptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<GroupPermissionOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(GroupPermissionOptionDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupPermissionOptionDto[]>(<any>null);
    }

    get(id: string | null): Observable<GroupPermissionDetailVm> {
        let url_ = this.baseUrl + "/api/GroupPermissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<GroupPermissionDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupPermissionDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GroupPermissionDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = GroupPermissionDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupPermissionDetailVm>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/GroupPermissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface INotificationsClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfNotificationDto>;
    create(command: CreateNotificationCommand): Observable<string>;
    getNotificationsOfUser(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<GetNotificationsOfUserResponse>;
    get(id: string | null): Observable<NotificationDetailVm>;
    update(id: string | null, command: UpdateNotificationCommand): Observable<string>;
    delete(id: string | null): Observable<FileResponse>;
    updateStatus(command: UpdateNotificationStatusCommand): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class NotificationsClient implements INotificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfNotificationDto> {
        let url_ = this.baseUrl + "/api/Notifications?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfNotificationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfNotificationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfNotificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfNotificationDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfNotificationDto>(<any>null);
    }

    create(command: CreateNotificationCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getNotificationsOfUser(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<GetNotificationsOfUserResponse> {
        let url_ = this.baseUrl + "/api/Notifications/GetNotificationsOfUser?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetNotificationsOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationsOfUser(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOfUserResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOfUserResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationsOfUser(response: HttpResponseBase): Observable<GetNotificationsOfUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = GetNotificationsOfUserResponse.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOfUserResponse>(<any>null);
    }

    get(id: string | null): Observable<NotificationDetailVm> {
        let url_ = this.baseUrl + "/api/Notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<NotificationDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NotificationDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = NotificationDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateNotificationCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateStatus(command: UpdateNotificationStatusCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Notifications/UpdateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IOrdersClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfOrderDto>;
    create(command: CreateOrderCommand): Observable<FileResponse>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfOrderOptionDto>;
    get(id: string | null): Observable<OrderDetailVm>;
    update(id: string | null, command: UpdateOrderCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClient implements IOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfOrderDto> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfOrderDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfOrderDto>(<any>null);
    }

    create(command: CreateOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfOrderOptionDto> {
        let url_ = this.baseUrl + "/api/Orders/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfOrderOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfOrderOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfOrderOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfOrderOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfOrderOptionDto>(<any>null);
    }

    get(id: string | null): Observable<OrderDetailVm> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OrderDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OrderDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = OrderDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IPermissionsClient {
    getAll(groupId?: string | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfPermissionDto>;
    upsert(command: UpsertPermissionCommand): Observable<FileResponse>;
    getPermissionsOfUser(query?: GetPermissionsOfUserQuery | null | undefined): Observable<PermissionOfUserDto[]>;
    getGroupPermissionsOfUser(): Observable<GroupPermissionOfUserDto[]>;
    get(id: string | null): Observable<PermissionDetailVm>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PermissionsClient implements IPermissionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(groupId?: string | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfPermissionDto> {
        let url_ = this.baseUrl + "/api/Permissions?";
        if (groupId !== undefined && groupId !== null)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfPermissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfPermissionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfPermissionDto>(<any>null);
    }

    upsert(command: UpsertPermissionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Permissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsert(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpsert(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getPermissionsOfUser(query?: GetPermissionsOfUserQuery | null | undefined): Observable<PermissionOfUserDto[]> {
        let url_ = this.baseUrl + "/api/Permissions/GetPermissionsOfUser?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPermissionsOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsOfUser(<any>response_);
                } catch (e) {
                    return <Observable<PermissionOfUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionOfUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsOfUser(response: HttpResponseBase): Observable<PermissionOfUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(PermissionOfUserDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionOfUserDto[]>(<any>null);
    }

    getGroupPermissionsOfUser(): Observable<GroupPermissionOfUserDto[]> {
        let url_ = this.baseUrl + "/api/Permissions/GetGroupPermissionsOfUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupPermissionsOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupPermissionsOfUser(<any>response_);
                } catch (e) {
                    return <Observable<GroupPermissionOfUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupPermissionOfUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupPermissionsOfUser(response: HttpResponseBase): Observable<GroupPermissionOfUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(GroupPermissionOfUserDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupPermissionOfUserDto[]>(<any>null);
    }

    get(id: string | null): Observable<PermissionDetailVm> {
        let url_ = this.baseUrl + "/api/Permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PermissionDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PermissionDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDetailVm>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IProductCategoriesClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductCategoryDto>;
    create(command: CreateProductCategoryCommand): Observable<FileResponse>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductCategoryOptionDto>;
    get(id: string | null): Observable<ProductCategoryDetailVm>;
    update(id: string | null, command: UpdateProductCategoryCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductCategoriesClient implements IProductCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductCategoryDto> {
        let url_ = this.baseUrl + "/api/ProductCategories?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfProductCategoryDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfProductCategoryDto>(<any>null);
    }

    create(command: CreateProductCategoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductCategoryOptionDto> {
        let url_ = this.baseUrl + "/api/ProductCategories/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfProductCategoryOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfProductCategoryOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfProductCategoryOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfProductCategoryOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfProductCategoryOptionDto>(<any>null);
    }

    get(id: string | null): Observable<ProductCategoryDetailVm> {
        let url_ = this.baseUrl + "/api/ProductCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductCategoryDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProductCategoryDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateProductCategoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IProductModelsClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductModelDto>;
    create(command: CreateProductModelCommand): Observable<FileResponse>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductModelOptionDto>;
    get(id: string | null): Observable<ProductModelDetailVm>;
    update(id: string | null, command: UpdateProductModelCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductModelsClient implements IProductModelsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductModelDto> {
        let url_ = this.baseUrl + "/api/ProductModels?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfProductModelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfProductModelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfProductModelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfProductModelDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfProductModelDto>(<any>null);
    }

    create(command: CreateProductModelCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductModels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductModelOptionDto> {
        let url_ = this.baseUrl + "/api/ProductModels/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfProductModelOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfProductModelOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfProductModelOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfProductModelOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfProductModelOptionDto>(<any>null);
    }

    get(id: string | null): Observable<ProductModelDetailVm> {
        let url_ = this.baseUrl + "/api/ProductModels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProductModelDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductModelDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductModelDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProductModelDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductModelDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateProductModelCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductModels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductModels/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IProductsClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductDto>;
    create(command: CreateProductCommand): Observable<FileResponse>;
    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductOptionDto>;
    get(id: string | null): Observable<ProductDetailVm>;
    update(id: string | null, command: UpdateProductCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductDto> {
        let url_ = this.baseUrl + "/api/Products?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfProductDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfProductDto>(<any>null);
    }

    create(command: CreateProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOptions(listOfId?: string[] | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfProductOptionDto> {
        let url_ = this.baseUrl + "/api/Products/GetOptions?";
        if (listOfId !== undefined && listOfId !== null)
            listOfId && listOfId.forEach(item => { url_ += "ListOfId=" + encodeURIComponent("" + item) + "&"; });
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfProductOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfProductOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<PagedListVmOfProductOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfProductOptionDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfProductOptionDto>(<any>null);
    }

    get(id: string | null): Observable<ProductDetailVm> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProductDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProductDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IRolesClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfRoleDto>;
    create(command: CreateRoleCommand): Observable<string>;
    getOptions(): Observable<RoleOptionDto[]>;
    get(id: string | null): Observable<RoleDetailVm>;
    update(id: string | null, command: UpdateRoleCommand): Observable<string>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RolesClient implements IRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfRoleDto> {
        let url_ = this.baseUrl + "/api/Roles?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfRoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfRoleDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfRoleDto>(<any>null);
    }

    create(command: CreateRoleCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getOptions(): Observable<RoleOptionDto[]> {
        let url_ = this.baseUrl + "/api/Roles/GetOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<RoleOptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleOptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<RoleOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(RoleOptionDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleOptionDto[]>(<any>null);
    }

    get(id: string | null): Observable<RoleDetailVm> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = RoleDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateRoleCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITempTrashsClient {
    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfTempTrashDto>;
    restoreEntity(command: RestoreTempTrashCommand): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class TempTrashsClient implements ITempTrashsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfTempTrashDto> {
        let url_ = this.baseUrl + "/api/TempTrashs?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfTempTrashDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfTempTrashDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfTempTrashDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfTempTrashDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfTempTrashDto>(<any>null);
    }

    restoreEntity(command: RestoreTempTrashCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/TempTrashs/RestoreEntity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRestoreEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreEntity(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreEntity(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IUsersClient {
    getAll(gender?: GenderEnum | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfUserDto>;
    create(command: CreateUserCommand): Observable<string>;
    getOptions(): Observable<UserOptionDto[]>;
    get(id: string | null): Observable<UserDetailVm>;
    update(id: string | null, command: UpdateUserCommand): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    updateUserRoles(id: string | null, command: UpdateUserRolesCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(gender?: GenderEnum | null | undefined, pageNumber?: number | undefined, pageSize?: number | undefined, textSearch?: string | null | undefined, orderBy?: string | null | undefined): Observable<PagedListVmOfUserDto> {
        let url_ = this.baseUrl + "/api/Users?";
        if (gender !== undefined && gender !== null)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (textSearch !== undefined && textSearch !== null)
            url_ += "TextSearch=" + encodeURIComponent("" + textSearch) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedListVmOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedListVmOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedListVmOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = PagedListVmOfUserDto.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedListVmOfUserDto>(<any>null);
    }

    create(command: CreateUserCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getOptions(): Observable<UserOptionDto[]> {
        let url_ = this.baseUrl + "/api/Users/GetOptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOptions(<any>response_);
                } catch (e) {
                    return <Observable<UserOptionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserOptionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOptions(response: HttpResponseBase): Observable<UserOptionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UserOptionDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserOptionDto[]>(<any>null);
    }

    get(id: string | null): Observable<UserDetailVm> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDetailVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserDetailVm.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailVm>(<any>null);
    }

    update(id: string | null, command: UpdateUserCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateUserRoles(id: string | null, command: UpdateUserRolesCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/UpdateUserRoles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserRoles(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserRoles(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export class RegisterCommand implements IRegisterCommand {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IRegisterCommand {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class LoginAccountCommand implements ILoginAccountCommand {
    userName?: string | undefined;
    password?: string | undefined;
    rememberMe?: boolean | undefined;

    constructor(data?: ILoginAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginAccountCommand {
    userName?: string | undefined;
    password?: string | undefined;
    rememberMe?: boolean | undefined;
}

export class LoginWith2faCommand implements ILoginWith2faCommand {
    code?: string | undefined;
    rememberMe?: boolean;

    constructor(data?: ILoginWith2faCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginWith2faCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginWith2faCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginWith2faCommand {
    code?: string | undefined;
    rememberMe?: boolean;
}

export class UpdateProfileCommand implements IUpdateProfileCommand {
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUpdateProfileCommand {
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class UserInforVm implements IUserInforVm {
    id?: string | undefined;
    coin?: number;
    balance?: number;
    userName?: string | undefined;
    email?: string | undefined;
    profile?: UserProfile | undefined;
    roles?: string[] | undefined;

    constructor(data?: IUserInforVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coin = _data["coin"];
            this.balance = _data["balance"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserInforVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserInforVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coin"] = this.coin;
        data["balance"] = this.balance;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserInforVm {
    id?: string | undefined;
    coin?: number;
    balance?: number;
    userName?: string | undefined;
    email?: string | undefined;
    profile?: UserProfile | undefined;
    roles?: string[] | undefined;
}

export class UserProfile implements IUserProfile {
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    avatar?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: GenderEnum | undefined;
    address?: string | undefined;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.avatar = _data["avatar"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["avatar"] = this.avatar;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        return data;
    }
}

export interface IUserProfile {
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    avatar?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: GenderEnum | undefined;
    address?: string | undefined;
}

export enum GenderEnum {
    Male = 1,
    Female = 2,
    Unknown = 3,
}

export class ChangePasswordCommand implements IChangePasswordCommand {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IChangePasswordCommand {
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string | undefined;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    code?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["code"] = this.code;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    code?: string | undefined;
}

export class SetPasswordCommand implements ISetPasswordCommand {
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: ISetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): SetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface ISetPasswordCommand {
    newPassword?: string | undefined;
    confirmPassword?: string | undefined;
}

export class SharedKeyAndQrCodeUriVm implements ISharedKeyAndQrCodeUriVm {
    sharedKey?: string | undefined;
    authenticatorUri?: string | undefined;

    constructor(data?: ISharedKeyAndQrCodeUriVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.authenticatorUri = _data["authenticatorUri"];
        }
    }

    static fromJS(data: any): SharedKeyAndQrCodeUriVm {
        data = typeof data === 'object' ? data : {};
        let result = new SharedKeyAndQrCodeUriVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["authenticatorUri"] = this.authenticatorUri;
        return data;
    }
}

export interface ISharedKeyAndQrCodeUriVm {
    sharedKey?: string | undefined;
    authenticatorUri?: string | undefined;
}

export class EnableAuthenticatorCommand implements IEnableAuthenticatorCommand {
    code?: string | undefined;

    constructor(data?: IEnableAuthenticatorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): EnableAuthenticatorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EnableAuthenticatorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface IEnableAuthenticatorCommand {
    code?: string | undefined;
}

export class Reset2faCommand implements IReset2faCommand {

    constructor(data?: IReset2faCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Reset2faCommand {
        data = typeof data === 'object' ? data : {};
        let result = new Reset2faCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IReset2faCommand {
}

export class ResetRecoveryCodeCommand implements IResetRecoveryCodeCommand {

    constructor(data?: IResetRecoveryCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ResetRecoveryCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetRecoveryCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IResetRecoveryCodeCommand {
}

export class Disable2faCommand implements IDisable2faCommand {
    code?: string | undefined;

    constructor(data?: IDisable2faCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Disable2faCommand {
        data = typeof data === 'object' ? data : {};
        let result = new Disable2faCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface IDisable2faCommand {
    code?: string | undefined;
}

export class PagedListVmOfControllerActionDto implements IPagedListVmOfControllerActionDto {
    data?: ControllerActionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfControllerActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ControllerActionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfControllerActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfControllerActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfControllerActionDto {
    data?: ControllerActionDto[] | undefined;
    page?: PageModel | undefined;
}

export class ControllerActionDto implements IControllerActionDto {
    id?: string | undefined;
    data?: ControllerActionData | undefined;
    apiResourceId?: string | undefined;
    apiResourceName?: string | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IControllerActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ControllerActionData.fromJS(_data["data"]) : <any>undefined;
            this.apiResourceId = _data["apiResourceId"];
            this.apiResourceName = _data["apiResourceName"];
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ControllerActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["apiResourceId"] = this.apiResourceId;
        data["apiResourceName"] = this.apiResourceName;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IControllerActionDto {
    id?: string | undefined;
    data?: ControllerActionData | undefined;
    apiResourceId?: string | undefined;
    apiResourceName?: string | undefined;
    auditData?: AuditableModel | undefined;
}

export class ControllerActionData implements IControllerActionData {
    name?: string | undefined;
    routePattern?: string | undefined;
    method?: string | undefined;
    description?: string | undefined;

    constructor(data?: IControllerActionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.routePattern = _data["routePattern"];
            this.method = _data["method"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ControllerActionData {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerActionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["routePattern"] = this.routePattern;
        data["method"] = this.method;
        data["description"] = this.description;
        return data;
    }
}

export interface IControllerActionData {
    name?: string | undefined;
    routePattern?: string | undefined;
    method?: string | undefined;
    description?: string | undefined;
}

export class BaseAuditableModel implements IBaseAuditableModel {
    createdBy?: string | undefined;
    created?: Date;

    constructor(data?: IBaseAuditableModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseAuditableModel {
        data = typeof data === 'object' ? data : {};
        let result = new BaseAuditableModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBaseAuditableModel {
    createdBy?: string | undefined;
    created?: Date;
}

export class AuditableModel extends BaseAuditableModel implements IAuditableModel {
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    lastDeletedBy?: string | undefined;
    lastDeleted?: Date | undefined;
    lastRestoredBy?: string | undefined;
    lastRestored?: Date | undefined;

    constructor(data?: IAuditableModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastDeletedBy = _data["lastDeletedBy"];
            this.lastDeleted = _data["lastDeleted"] ? new Date(_data["lastDeleted"].toString()) : <any>undefined;
            this.lastRestoredBy = _data["lastRestoredBy"];
            this.lastRestored = _data["lastRestored"] ? new Date(_data["lastRestored"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastDeletedBy"] = this.lastDeletedBy;
        data["lastDeleted"] = this.lastDeleted ? this.lastDeleted.toISOString() : <any>undefined;
        data["lastRestoredBy"] = this.lastRestoredBy;
        data["lastRestored"] = this.lastRestored ? this.lastRestored.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAuditableModel extends IBaseAuditableModel {
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    lastDeletedBy?: string | undefined;
    lastDeleted?: Date | undefined;
    lastRestoredBy?: string | undefined;
    lastRestored?: Date | undefined;
}

export class PageModel implements IPageModel {
    number?: number;
    size?: number;
    total?: number;

    constructor(data?: IPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.size = _data["size"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PageModel {
        data = typeof data === 'object' ? data : {};
        let result = new PageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["size"] = this.size;
        data["total"] = this.total;
        return data;
    }
}

export interface IPageModel {
    number?: number;
    size?: number;
    total?: number;
}

export class PagedListVmOfControllerActionOptionDto implements IPagedListVmOfControllerActionOptionDto {
    data?: ControllerActionOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfControllerActionOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ControllerActionOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfControllerActionOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfControllerActionOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfControllerActionOptionDto {
    data?: ControllerActionOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class OptionModel implements IOptionModel {
    value?: string | undefined;
    label?: string | undefined;

    constructor(data?: IOptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): OptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new OptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data;
    }
}

export interface IOptionModel {
    value?: string | undefined;
    label?: string | undefined;
}

export class ControllerActionOptionDto extends OptionModel implements IControllerActionOptionDto {

    constructor(data?: IControllerActionOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ControllerActionOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerActionOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IControllerActionOptionDto extends IOptionModel {
}

export class ControllerActionDetailVm implements IControllerActionDetailVm {
    id?: string | undefined;
    data?: ControllerActionData | undefined;
    apiResourceId?: number;
    apiResourceName?: string | undefined;

    constructor(data?: IControllerActionDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ControllerActionData.fromJS(_data["data"]) : <any>undefined;
            this.apiResourceId = _data["apiResourceId"];
            this.apiResourceName = _data["apiResourceName"];
        }
    }

    static fromJS(data: any): ControllerActionDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerActionDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["apiResourceId"] = this.apiResourceId;
        data["apiResourceName"] = this.apiResourceName;
        return data;
    }
}

export interface IControllerActionDetailVm {
    id?: string | undefined;
    data?: ControllerActionData | undefined;
    apiResourceId?: number;
    apiResourceName?: string | undefined;
}

export class SyncControllerActionCommand implements ISyncControllerActionCommand {
    apiResourceId?: string | undefined;
    actions?: SyncControllerAction[] | undefined;

    constructor(data?: ISyncControllerActionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiResourceId = _data["apiResourceId"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(SyncControllerAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SyncControllerActionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SyncControllerActionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiResourceId"] = this.apiResourceId;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISyncControllerActionCommand {
    apiResourceId?: string | undefined;
    actions?: SyncControllerAction[] | undefined;
}

export class SyncControllerAction implements ISyncControllerAction {
    name?: string | undefined;
    routePattern?: string | undefined;
    method?: string | undefined;
    description?: string | undefined;

    constructor(data?: ISyncControllerAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.routePattern = _data["routePattern"];
            this.method = _data["method"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SyncControllerAction {
        data = typeof data === 'object' ? data : {};
        let result = new SyncControllerAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["routePattern"] = this.routePattern;
        data["method"] = this.method;
        data["description"] = this.description;
        return data;
    }
}

export interface ISyncControllerAction {
    name?: string | undefined;
    routePattern?: string | undefined;
    method?: string | undefined;
    description?: string | undefined;
}

export class UpsertControllerActionCommand implements IUpsertControllerActionCommand {
    id?: string | undefined;
    apiResourceId?: string | undefined;
    data?: ControllerActionData | undefined;

    constructor(data?: IUpsertControllerActionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.apiResourceId = _data["apiResourceId"];
            this.data = _data["data"] ? ControllerActionData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertControllerActionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertControllerActionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["apiResourceId"] = this.apiResourceId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpsertControllerActionCommand {
    id?: string | undefined;
    apiResourceId?: string | undefined;
    data?: ControllerActionData | undefined;
}

export class PagedListVmOfApiResourceDto implements IPagedListVmOfApiResourceDto {
    data?: ApiResourceDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfApiResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ApiResourceDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfApiResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfApiResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfApiResourceDto {
    data?: ApiResourceDto[] | undefined;
    page?: PageModel | undefined;
}

export class ApiResourceDto implements IApiResourceDto {
    id?: string | undefined;
    data?: ApiResourceEntityData | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IApiResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ApiResourceEntityData.fromJS(_data["data"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IApiResourceDto {
    id?: string | undefined;
    data?: ApiResourceEntityData | undefined;
    auditData?: AuditableModel | undefined;
}

export class ApiResourceEntityData implements IApiResourceEntityData {
    name?: string | undefined;
    specification?: string | undefined;
    description?: string | undefined;

    constructor(data?: IApiResourceEntityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.specification = _data["specification"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ApiResourceEntityData {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceEntityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["specification"] = this.specification;
        data["description"] = this.description;
        return data;
    }
}

export interface IApiResourceEntityData {
    name?: string | undefined;
    specification?: string | undefined;
    description?: string | undefined;
}

export class ApiResourceOptionDto extends OptionModel implements IApiResourceOptionDto {

    constructor(data?: IApiResourceOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ApiResourceOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IApiResourceOptionDto extends IOptionModel {
}

export class ApiResourceDetailVm implements IApiResourceDetailVm {
    id?: string | undefined;
    data?: ApiResourceEntityData | undefined;

    constructor(data?: IApiResourceDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ApiResourceEntityData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResourceDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IApiResourceDetailVm {
    id?: string | undefined;
    data?: ApiResourceEntityData | undefined;
}

export class UpsertApiResourceCommand implements IUpsertApiResourceCommand {
    id?: string | undefined;
    data?: ApiResourceEntityData | undefined;

    constructor(data?: IUpsertApiResourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ApiResourceEntityData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertApiResourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertApiResourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpsertApiResourceCommand {
    id?: string | undefined;
    data?: ApiResourceEntityData | undefined;
}

export class PagedListVmOfArticleDto implements IPagedListVmOfArticleDto {
    data?: ArticleDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfArticleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ArticleDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfArticleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfArticleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfArticleDto {
    data?: ArticleDto[] | undefined;
    page?: PageModel | undefined;
}

export class AuditableEntity implements IAuditableEntity {
    id?: string | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAuditableEntity {
    id?: string | undefined;
    auditData?: AuditableModel | undefined;
}

export class ArticleDto extends AuditableEntity implements IArticleDto {
    data?: ArticleData | undefined;

    constructor(data?: IArticleDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ArticleData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ArticleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IArticleDto extends IAuditableEntity {
    data?: ArticleData | undefined;
}

export class ArticleData implements IArticleData {
    name?: string | undefined;
    keyTitle?: string | undefined;
    title?: string | undefined;
    image?: string | undefined;
    content?: string | undefined;

    constructor(data?: IArticleData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.keyTitle = _data["keyTitle"];
            this.title = _data["title"];
            this.image = _data["image"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ArticleData {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["keyTitle"] = this.keyTitle;
        data["title"] = this.title;
        data["image"] = this.image;
        data["content"] = this.content;
        return data;
    }
}

export interface IArticleData {
    name?: string | undefined;
    keyTitle?: string | undefined;
    title?: string | undefined;
    image?: string | undefined;
    content?: string | undefined;
}

export class PagedListVmOfArticleOptionDto implements IPagedListVmOfArticleOptionDto {
    data?: ArticleOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfArticleOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ArticleOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfArticleOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfArticleOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfArticleOptionDto {
    data?: ArticleOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class OptionModelOfString implements IOptionModelOfString {
    value?: string | undefined;
    label?: string | undefined;

    constructor(data?: IOptionModelOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): OptionModelOfString {
        data = typeof data === 'object' ? data : {};
        let result = new OptionModelOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data;
    }
}

export interface IOptionModelOfString {
    value?: string | undefined;
    label?: string | undefined;
}

export class ArticleOptionDto extends OptionModelOfString implements IArticleOptionDto {

    constructor(data?: IArticleOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ArticleOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IArticleOptionDto extends IOptionModelOfString {
}

export class ArticleDetailVm implements IArticleDetailVm {
    id?: string | undefined;
    data?: ArticleData | undefined;

    constructor(data?: IArticleDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ArticleData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ArticleDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IArticleDetailVm {
    id?: string | undefined;
    data?: ArticleData | undefined;
}

export class CreateArticleCommand implements ICreateArticleCommand {
    data?: ArticleData | undefined;

    constructor(data?: ICreateArticleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ArticleData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateArticleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateArticleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateArticleCommand {
    data?: ArticleData | undefined;
}

export class UpdateArticleCommand implements IUpdateArticleCommand {
    id?: string | undefined;
    data?: ArticleData | undefined;

    constructor(data?: IUpdateArticleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ArticleData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateArticleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArticleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateArticleCommand {
    id?: string | undefined;
    data?: ArticleData | undefined;
}

export class PagedListVmOfCashBookDto implements IPagedListVmOfCashBookDto {
    data?: CashBookDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfCashBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CashBookDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfCashBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfCashBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfCashBookDto {
    data?: CashBookDto[] | undefined;
    page?: PageModel | undefined;
}

export class CashBookDto extends AuditableEntity implements ICashBookDto {
    data?: CashBookData | undefined;

    constructor(data?: ICashBookDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? CashBookData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICashBookDto extends IAuditableEntity {
    data?: CashBookData | undefined;
}

export class CashBookData implements ICashBookData {
    type?: CashBookTypeEnum;
    amount?: number;
    note?: string | undefined;

    constructor(data?: ICashBookData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): CashBookData {
        data = typeof data === 'object' ? data : {};
        let result = new CashBookData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["note"] = this.note;
        return data;
    }
}

export interface ICashBookData {
    type?: CashBookTypeEnum;
    amount?: number;
    note?: string | undefined;
}

export enum CashBookTypeEnum {
    Income = 1,
    Expense = 2,
}

export class PagedListVmOfCashBookOptionDto implements IPagedListVmOfCashBookOptionDto {
    data?: CashBookOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfCashBookOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CashBookOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfCashBookOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfCashBookOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfCashBookOptionDto {
    data?: CashBookOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class CashBookOptionDto extends OptionModelOfString implements ICashBookOptionDto {

    constructor(data?: ICashBookOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CashBookOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashBookOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICashBookOptionDto extends IOptionModelOfString {
}

export class CashBookDetailVm implements ICashBookDetailVm {
    id?: string | undefined;
    data?: CashBookData | undefined;

    constructor(data?: ICashBookDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? CashBookData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashBookDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new CashBookDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICashBookDetailVm {
    id?: string | undefined;
    data?: CashBookData | undefined;
}

export class CreateCashBookCommand implements ICreateCashBookCommand {
    data?: CashBookData | undefined;

    constructor(data?: ICreateCashBookCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? CashBookData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCashBookCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashBookCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateCashBookCommand {
    data?: CashBookData | undefined;
}

export class UpdateCashBookCommand implements IUpdateCashBookCommand {
    id?: string | undefined;
    data?: CashBookData | undefined;

    constructor(data?: IUpdateCashBookCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? CashBookData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateCashBookCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCashBookCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateCashBookCommand {
    id?: string | undefined;
    data?: CashBookData | undefined;
}

export class PagedListVmOfFileDto implements IPagedListVmOfFileDto {
    data?: FileDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(FileDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfFileDto {
    data?: FileDto[] | undefined;
    page?: PageModel | undefined;
}

export class FileDto implements IFileDto {
    id?: string | undefined;
    filePath?: string | undefined;
    used?: boolean;
    data?: FileData | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.filePath = _data["filePath"];
            this.used = _data["used"];
            this.data = _data["data"] ? FileData.fromJS(_data["data"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["used"] = this.used;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileDto {
    id?: string | undefined;
    filePath?: string | undefined;
    used?: boolean;
    data?: FileData | undefined;
    auditData?: AuditableModel | undefined;
}

export class FileData implements IFileData {
    name?: string | undefined;
    extension?: string | undefined;
    size?: number;
    contentType?: string | undefined;
    folder?: string | undefined;

    constructor(data?: IFileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.extension = _data["extension"];
            this.size = _data["size"];
            this.contentType = _data["contentType"];
            this.folder = _data["folder"];
        }
    }

    static fromJS(data: any): FileData {
        data = typeof data === 'object' ? data : {};
        let result = new FileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["extension"] = this.extension;
        data["size"] = this.size;
        data["contentType"] = this.contentType;
        data["folder"] = this.folder;
        return data;
    }
}

export interface IFileData {
    name?: string | undefined;
    extension?: string | undefined;
    size?: number;
    contentType?: string | undefined;
    folder?: string | undefined;
}

export class FileDetailVm implements IFileDetailVm {
    id?: string | undefined;
    filePath?: string | undefined;
    used?: boolean;
    data?: FileData | undefined;

    constructor(data?: IFileDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.filePath = _data["filePath"];
            this.used = _data["used"];
            this.data = _data["data"] ? FileData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new FileDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["used"] = this.used;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileDetailVm {
    id?: string | undefined;
    filePath?: string | undefined;
    used?: boolean;
    data?: FileData | undefined;
}

export class UploadFileResponse implements IUploadFileResponse {
    id?: string | undefined;
    filePath?: string | undefined;
    used?: boolean;
    data?: FileData | undefined;

    constructor(data?: IUploadFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.filePath = _data["filePath"];
            this.used = _data["used"];
            this.data = _data["data"] ? FileData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UploadFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["filePath"] = this.filePath;
        data["used"] = this.used;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUploadFileResponse {
    id?: string | undefined;
    filePath?: string | undefined;
    used?: boolean;
    data?: FileData | undefined;
}

export class PagedListVmOfGroupPermissionDto implements IPagedListVmOfGroupPermissionDto {
    data?: GroupPermissionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfGroupPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GroupPermissionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfGroupPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfGroupPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfGroupPermissionDto {
    data?: GroupPermissionDto[] | undefined;
    page?: PageModel | undefined;
}

export class GroupPermissionDto implements IGroupPermissionDto {
    id?: string | undefined;
    data?: GroupPermissionData | undefined;
    auditData?: AuditableModel | undefined;
    permissions?: PermissionDto[] | undefined;

    constructor(data?: IGroupPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? GroupPermissionData.fromJS(_data["data"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupPermissionDto {
    id?: string | undefined;
    data?: GroupPermissionData | undefined;
    auditData?: AuditableModel | undefined;
    permissions?: PermissionDto[] | undefined;
}

export class GroupPermissionData implements IGroupPermissionData {
    parentId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGroupPermissionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GroupPermissionData {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermissionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IGroupPermissionData {
    parentId?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export class PermissionDto implements IPermissionDto {
    id?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    data?: PermissionData | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.data = _data["data"] ? PermissionData.fromJS(_data["data"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPermissionDto {
    id?: string | undefined;
    groupId?: string | undefined;
    groupName?: string | undefined;
    data?: PermissionData | undefined;
    auditData?: AuditableModel | undefined;
}

export class PermissionData implements IPermissionData {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPermissionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionData {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IPermissionData {
    name?: string | undefined;
    description?: string | undefined;
}

export class GroupPermissionOptionDto extends OptionModel implements IGroupPermissionOptionDto {

    constructor(data?: IGroupPermissionOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): GroupPermissionOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermissionOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGroupPermissionOptionDto extends IOptionModel {
}

export class GroupPermissionDetailVm implements IGroupPermissionDetailVm {
    id?: string | undefined;
    data?: GroupPermissionData | undefined;

    constructor(data?: IGroupPermissionDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? GroupPermissionData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupPermissionDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermissionDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupPermissionDetailVm {
    id?: string | undefined;
    data?: GroupPermissionData | undefined;
}

export class UpsertGroupPermissionCommand implements IUpsertGroupPermissionCommand {
    id?: string | undefined;
    data?: GroupPermissionData | undefined;

    constructor(data?: IUpsertGroupPermissionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? GroupPermissionData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpsertGroupPermissionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertGroupPermissionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpsertGroupPermissionCommand {
    id?: string | undefined;
    data?: GroupPermissionData | undefined;
}

export class PagedListVmOfNotificationDto implements IPagedListVmOfNotificationDto {
    data?: NotificationDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfNotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(NotificationDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfNotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfNotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfNotificationDto {
    data?: NotificationDto[] | undefined;
    page?: PageModel | undefined;
}

export class NotificationDto implements INotificationDto {
    id?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: NotificationReceiver[] | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(NotificationReceiver.fromJS(item));
            }
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item.toJSON());
        }
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationDto {
    id?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: NotificationReceiver[] | undefined;
    auditData?: AuditableModel | undefined;
}

export class NotificationData implements INotificationData {
    message?: string | undefined;
    messageParams?: any | undefined;
    title?: string | undefined;
    titleParams?: any | undefined;
    link?: string | undefined;
    type?: NotificationTypeEnum;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.messageParams = _data["messageParams"];
            this.title = _data["title"];
            this.titleParams = _data["titleParams"];
            this.link = _data["link"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["messageParams"] = this.messageParams;
        data["title"] = this.title;
        data["titleParams"] = this.titleParams;
        data["link"] = this.link;
        data["type"] = this.type;
        return data;
    }
}

export interface INotificationData {
    message?: string | undefined;
    messageParams?: any | undefined;
    title?: string | undefined;
    titleParams?: any | undefined;
    link?: string | undefined;
    type?: NotificationTypeEnum;
}

export enum NotificationTypeEnum {
    Single = 1,
    Multiple = 2,
    All = 3,
}

export class NotificationReceiver implements INotificationReceiver {
    notificationId?: string | undefined;
    userId?: string | undefined;
    status?: NotificationStatusEnum;
    notification?: Notification | undefined;
    user?: ApplicationUser | undefined;

    constructor(data?: INotificationReceiver) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationId = _data["notificationId"];
            this.userId = _data["userId"];
            this.status = _data["status"];
            this.notification = _data["notification"] ? Notification.fromJS(_data["notification"]) : <any>undefined;
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationReceiver {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationReceiver();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationId"] = this.notificationId;
        data["userId"] = this.userId;
        data["status"] = this.status;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationReceiver {
    notificationId?: string | undefined;
    userId?: string | undefined;
    status?: NotificationStatusEnum;
    notification?: Notification | undefined;
    user?: ApplicationUser | undefined;
}

export enum NotificationStatusEnum {
    Unread = 1,
    Read = 2,
    Deleted = 3,
}

export class Notification extends AuditableEntity implements INotification {
    senderId?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: NotificationReceiver[] | undefined;
    sender?: ApplicationUser | undefined;
    domainEvents?: DomainEvent[] | undefined;

    constructor(data?: INotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.senderId = _data["senderId"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(NotificationReceiver.fromJS(item));
            }
            this.sender = _data["sender"] ? ApplicationUser.fromJS(_data["sender"]) : <any>undefined;
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(DomainEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderId"] = this.senderId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item.toJSON());
        }
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface INotification extends IAuditableEntity {
    senderId?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: NotificationReceiver[] | undefined;
    sender?: ApplicationUser | undefined;
    domainEvents?: DomainEvent[] | undefined;
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUser extends IIdentityUserOfString {
}

export class ApplicationUser extends IdentityUser implements IApplicationUser {
    profile?: UserProfile | undefined;
    auditData?: AuditableModel | undefined;
    claims?: ApplicationUserClaim[] | undefined;
    logins?: ApplicationUserLogin[] | undefined;
    tokens?: ApplicationUserToken[] | undefined;
    userRoles?: ApplicationUserRole[] | undefined;
    notificationReceivers?: NotificationReceiver[] | undefined;

    constructor(data?: IApplicationUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ApplicationUserClaim.fromJS(item));
            }
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(ApplicationUserLogin.fromJS(item));
            }
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(ApplicationUserToken.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(ApplicationUserRole.fromJS(item));
            }
            if (Array.isArray(_data["notificationReceivers"])) {
                this.notificationReceivers = [] as any;
                for (let item of _data["notificationReceivers"])
                    this.notificationReceivers!.push(NotificationReceiver.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.notificationReceivers)) {
            data["notificationReceivers"] = [];
            for (let item of this.notificationReceivers)
                data["notificationReceivers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUser extends IIdentityUser {
    profile?: UserProfile | undefined;
    auditData?: AuditableModel | undefined;
    claims?: ApplicationUserClaim[] | undefined;
    logins?: ApplicationUserLogin[] | undefined;
    tokens?: ApplicationUserToken[] | undefined;
    userRoles?: ApplicationUserRole[] | undefined;
    notificationReceivers?: NotificationReceiver[] | undefined;
}

export class IdentityUserClaimOfString implements IIdentityUserClaimOfString {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityUserClaimOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityUserClaimOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserClaimOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityUserClaimOfString {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class ApplicationUserClaim extends IdentityUserClaimOfString implements IApplicationUserClaim {
    user?: ApplicationUser | undefined;

    constructor(data?: IApplicationUserClaim) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUserClaim extends IIdentityUserClaimOfString {
    user?: ApplicationUser | undefined;
}

export class IdentityUserLoginOfString implements IIdentityUserLoginOfString {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IIdentityUserLoginOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.providerDisplayName = _data["providerDisplayName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): IdentityUserLoginOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserLoginOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["providerDisplayName"] = this.providerDisplayName;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IIdentityUserLoginOfString {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;
}

export class ApplicationUserLogin extends IdentityUserLoginOfString implements IApplicationUserLogin {
    user?: ApplicationUser | undefined;

    constructor(data?: IApplicationUserLogin) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUserLogin extends IIdentityUserLoginOfString {
    user?: ApplicationUser | undefined;
}

export class IdentityUserTokenOfString implements IIdentityUserTokenOfString {
    userId?: string | undefined;
    loginProvider?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IIdentityUserTokenOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdentityUserTokenOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserTokenOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IIdentityUserTokenOfString {
    userId?: string | undefined;
    loginProvider?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class ApplicationUserToken extends IdentityUserTokenOfString implements IApplicationUserToken {
    user?: ApplicationUser | undefined;

    constructor(data?: IApplicationUserToken) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserToken {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUserToken extends IIdentityUserTokenOfString {
    user?: ApplicationUser | undefined;
}

export class IdentityUserRoleOfString implements IIdentityUserRoleOfString {
    userId?: string | undefined;
    roleId?: string | undefined;

    constructor(data?: IIdentityUserRoleOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): IdentityUserRoleOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserRoleOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IIdentityUserRoleOfString {
    userId?: string | undefined;
    roleId?: string | undefined;
}

export class ApplicationUserRole extends IdentityUserRoleOfString implements IApplicationUserRole {
    user?: ApplicationUser | undefined;
    role?: ApplicationRole | undefined;

    constructor(data?: IApplicationUserRole) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUserRole extends IIdentityUserRoleOfString {
    user?: ApplicationUser | undefined;
    role?: ApplicationRole | undefined;
}

export class IdentityRoleOfString implements IIdentityRoleOfString {
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityRoleOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleOfString {
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class IdentityRole extends IdentityRoleOfString implements IIdentityRole {

    constructor(data?: IIdentityRole) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityRole {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityRole extends IIdentityRoleOfString {
}

export class ApplicationRole extends IdentityRole implements IApplicationRole {
    description?: string | undefined;
    auditData?: AuditableModel | undefined;
    rolePermissions?: RolePermission[] | undefined;
    userRoles?: ApplicationUserRole[] | undefined;
    roleClaims?: ApplicationRoleClaim[] | undefined;

    constructor(data?: IApplicationRole) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermission.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(ApplicationUserRole.fromJS(item));
            }
            if (Array.isArray(_data["roleClaims"])) {
                this.roleClaims = [] as any;
                for (let item of _data["roleClaims"])
                    this.roleClaims!.push(ApplicationRoleClaim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.roleClaims)) {
            data["roleClaims"] = [];
            for (let item of this.roleClaims)
                data["roleClaims"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationRole extends IIdentityRole {
    description?: string | undefined;
    auditData?: AuditableModel | undefined;
    rolePermissions?: RolePermission[] | undefined;
    userRoles?: ApplicationUserRole[] | undefined;
    roleClaims?: ApplicationRoleClaim[] | undefined;
}

export class RolePermission implements IRolePermission {
    roleId?: string | undefined;
    permissionId?: string | undefined;
    role?: ApplicationRole | undefined;
    permission?: Permission | undefined;

    constructor(data?: IRolePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
            this.permission = _data["permission"] ? Permission.fromJS(_data["permission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RolePermission {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRolePermission {
    roleId?: string | undefined;
    permissionId?: string | undefined;
    role?: ApplicationRole | undefined;
    permission?: Permission | undefined;
}

export class Permission extends AuditableEntity implements IPermission {
    groupId?: string | undefined;
    data?: PermissionData | undefined;
    group?: GroupPermission | undefined;
    actionPermissions?: ActionPermission[] | undefined;
    rolePermissions?: RolePermission[] | undefined;

    constructor(data?: IPermission) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupId = _data["groupId"];
            this.data = _data["data"] ? PermissionData.fromJS(_data["data"]) : <any>undefined;
            this.group = _data["group"] ? GroupPermission.fromJS(_data["group"]) : <any>undefined;
            if (Array.isArray(_data["actionPermissions"])) {
                this.actionPermissions = [] as any;
                for (let item of _data["actionPermissions"])
                    this.actionPermissions!.push(ActionPermission.fromJS(item));
            }
            if (Array.isArray(_data["rolePermissions"])) {
                this.rolePermissions = [] as any;
                for (let item of _data["rolePermissions"])
                    this.rolePermissions!.push(RolePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.actionPermissions)) {
            data["actionPermissions"] = [];
            for (let item of this.actionPermissions)
                data["actionPermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.rolePermissions)) {
            data["rolePermissions"] = [];
            for (let item of this.rolePermissions)
                data["rolePermissions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPermission extends IAuditableEntity {
    groupId?: string | undefined;
    data?: PermissionData | undefined;
    group?: GroupPermission | undefined;
    actionPermissions?: ActionPermission[] | undefined;
    rolePermissions?: RolePermission[] | undefined;
}

export class GroupPermission extends AuditableEntity implements IGroupPermission {
    data?: GroupPermissionData | undefined;
    permissions?: Permission[] | undefined;

    constructor(data?: IGroupPermission) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? GroupPermissionData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupPermission {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGroupPermission extends IAuditableEntity {
    data?: GroupPermissionData | undefined;
    permissions?: Permission[] | undefined;
}

export class ActionPermission implements IActionPermission {
    controllerActionId?: string | undefined;
    permissionId?: string | undefined;
    controllerAction?: ControllerAction | undefined;
    permission?: Permission | undefined;

    constructor(data?: IActionPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerActionId = _data["controllerActionId"];
            this.permissionId = _data["permissionId"];
            this.controllerAction = _data["controllerAction"] ? ControllerAction.fromJS(_data["controllerAction"]) : <any>undefined;
            this.permission = _data["permission"] ? Permission.fromJS(_data["permission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionPermission {
        data = typeof data === 'object' ? data : {};
        let result = new ActionPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerActionId"] = this.controllerActionId;
        data["permissionId"] = this.permissionId;
        data["controllerAction"] = this.controllerAction ? this.controllerAction.toJSON() : <any>undefined;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActionPermission {
    controllerActionId?: string | undefined;
    permissionId?: string | undefined;
    controllerAction?: ControllerAction | undefined;
    permission?: Permission | undefined;
}

export class ControllerAction extends AuditableEntity implements IControllerAction {
    apiResourceId?: string | undefined;
    data?: ControllerActionData | undefined;
    apiResource?: ApiResourceEntity | undefined;
    actionPermissions?: ActionPermission[] | undefined;

    constructor(data?: IControllerAction) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiResourceId = _data["apiResourceId"];
            this.data = _data["data"] ? ControllerActionData.fromJS(_data["data"]) : <any>undefined;
            this.apiResource = _data["apiResource"] ? ApiResourceEntity.fromJS(_data["apiResource"]) : <any>undefined;
            if (Array.isArray(_data["actionPermissions"])) {
                this.actionPermissions = [] as any;
                for (let item of _data["actionPermissions"])
                    this.actionPermissions!.push(ActionPermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControllerAction {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiResourceId"] = this.apiResourceId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["apiResource"] = this.apiResource ? this.apiResource.toJSON() : <any>undefined;
        if (Array.isArray(this.actionPermissions)) {
            data["actionPermissions"] = [];
            for (let item of this.actionPermissions)
                data["actionPermissions"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IControllerAction extends IAuditableEntity {
    apiResourceId?: string | undefined;
    data?: ControllerActionData | undefined;
    apiResource?: ApiResourceEntity | undefined;
    actionPermissions?: ActionPermission[] | undefined;
}

export class ApiResourceEntity extends AuditableEntity implements IApiResourceEntity {
    data?: ApiResourceEntityData | undefined;

    constructor(data?: IApiResourceEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ApiResourceEntityData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiResourceEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApiResourceEntity extends IAuditableEntity {
    data?: ApiResourceEntityData | undefined;
}

export class IdentityRoleClaimOfString implements IIdentityRoleClaimOfString {
    id?: number;
    roleId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityRoleClaimOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityRoleClaimOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleClaimOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityRoleClaimOfString {
    id?: number;
    roleId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class ApplicationRoleClaim extends IdentityRoleClaimOfString implements IApplicationRoleClaim {
    role?: ApplicationRole | undefined;

    constructor(data?: IApplicationRoleClaim) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.role = _data["role"] ? ApplicationRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationRoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationRoleClaim extends IIdentityRoleClaimOfString {
    role?: ApplicationRole | undefined;
}

export abstract class DomainEvent implements IDomainEvent {
    dateOccurred?: Date;

    constructor(data?: IDomainEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateOccurred = _data["dateOccurred"] ? new Date(_data["dateOccurred"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DomainEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DomainEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateOccurred"] = this.dateOccurred ? this.dateOccurred.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDomainEvent {
    dateOccurred?: Date;
}

export class PagedListVmOfNotificationOfUserDto implements IPagedListVmOfNotificationOfUserDto {
    data?: NotificationOfUserDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfNotificationOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(NotificationOfUserDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfNotificationOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfNotificationOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfNotificationOfUserDto {
    data?: NotificationOfUserDto[] | undefined;
    page?: PageModel | undefined;
}

export class GetNotificationsOfUserResponse extends PagedListVmOfNotificationOfUserDto implements IGetNotificationsOfUserResponse {
    totalUnread?: number;

    constructor(data?: IGetNotificationsOfUserResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.totalUnread = _data["totalUnread"];
        }
    }

    static fromJS(data: any): GetNotificationsOfUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOfUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalUnread"] = this.totalUnread;
        super.toJSON(data);
        return data;
    }
}

export interface IGetNotificationsOfUserResponse extends IPagedListVmOfNotificationOfUserDto {
    totalUnread?: number;
}

export class NotificationOfUserDto implements INotificationOfUserDto {
    id?: string | undefined;
    senderAvatar?: string | undefined;
    data?: NotificationData | undefined;
    status?: NotificationStatusEnum;
    auditData?: AuditableModel | undefined;

    constructor(data?: INotificationOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.senderAvatar = _data["senderAvatar"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.status = _data["status"];
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["senderAvatar"] = this.senderAvatar;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationOfUserDto {
    id?: string | undefined;
    senderAvatar?: string | undefined;
    data?: NotificationData | undefined;
    status?: NotificationStatusEnum;
    auditData?: AuditableModel | undefined;
}

export class NotificationDetailVm implements INotificationDetailVm {
    id?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: string[] | undefined;

    constructor(data?: INotificationDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item);
        }
        return data;
    }
}

export interface INotificationDetailVm {
    id?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: string[] | undefined;
}

export class CreateNotificationCommand implements ICreateNotificationCommand {
    receivers?: string[] | undefined;
    data?: CreateNotificationData | undefined;

    constructor(data?: ICreateNotificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(item);
            }
            this.data = _data["data"] ? CreateNotificationData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateNotificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item);
        }
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateNotificationCommand {
    receivers?: string[] | undefined;
    data?: CreateNotificationData | undefined;
}

export class CreateNotificationData implements ICreateNotificationData {
    message?: string | undefined;
    title?: string | undefined;
    type?: NotificationTypeEnum | undefined;

    constructor(data?: ICreateNotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.title = _data["title"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateNotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["title"] = this.title;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateNotificationData {
    message?: string | undefined;
    title?: string | undefined;
    type?: NotificationTypeEnum | undefined;
}

export class UpdateNotificationCommand implements IUpdateNotificationCommand {
    id?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: string[] | undefined;

    constructor(data?: IUpdateNotificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateNotificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item);
        }
        return data;
    }
}

export interface IUpdateNotificationCommand {
    id?: string | undefined;
    data?: NotificationData | undefined;
    receivers?: string[] | undefined;
}

export class UpdateNotificationStatusCommand implements IUpdateNotificationStatusCommand {
    id?: string | undefined;
    status?: NotificationStatusEnum;

    constructor(data?: IUpdateNotificationStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateNotificationStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateNotificationStatusCommand {
    id?: string | undefined;
    status?: NotificationStatusEnum;
}

export class PagedListVmOfOrderDto implements IPagedListVmOfOrderDto {
    data?: OrderDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfOrderDto {
    data?: OrderDto[] | undefined;
    page?: PageModel | undefined;
}

export class OrderDto extends AuditableEntity implements IOrderDto {
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;

    constructor(data?: IOrderDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? OrderData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(OrderProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOrderDto extends IAuditableEntity {
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;
}

export class OrderData implements IOrderData {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    channel?: ChannelEnum;
    paymentMethod?: PaymentMethodEnum;
    productsPrice?: number;
    debt?: number;
    discount?: number;
    shippingFeeIn?: number;
    shippingFeeOut?: number;
    paid?: number;
    status?: OrderStatusEnum;
    note?: string | undefined;

    constructor(data?: IOrderData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.channel = _data["channel"];
            this.paymentMethod = _data["paymentMethod"];
            this.productsPrice = _data["productsPrice"];
            this.debt = _data["debt"];
            this.discount = _data["discount"];
            this.shippingFeeIn = _data["shippingFeeIn"];
            this.shippingFeeOut = _data["shippingFeeOut"];
            this.paid = _data["paid"];
            this.status = _data["status"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): OrderData {
        data = typeof data === 'object' ? data : {};
        let result = new OrderData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["channel"] = this.channel;
        data["paymentMethod"] = this.paymentMethod;
        data["productsPrice"] = this.productsPrice;
        data["debt"] = this.debt;
        data["discount"] = this.discount;
        data["shippingFeeIn"] = this.shippingFeeIn;
        data["shippingFeeOut"] = this.shippingFeeOut;
        data["paid"] = this.paid;
        data["status"] = this.status;
        data["note"] = this.note;
        return data;
    }
}

export interface IOrderData {
    name?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    channel?: ChannelEnum;
    paymentMethod?: PaymentMethodEnum;
    productsPrice?: number;
    debt?: number;
    discount?: number;
    shippingFeeIn?: number;
    shippingFeeOut?: number;
    paid?: number;
    status?: OrderStatusEnum;
    note?: string | undefined;
}

export enum ChannelEnum {
    Facebook = 1,
    Website = 2,
    Shopee = 3,
    Instagram = 4,
}

export enum PaymentMethodEnum {
    COD = 1,
    Online = 2,
}

export enum OrderStatusEnum {
    Initialization = 1,
    Delivering = 2,
    Canceled = 3,
    Accomplished = 4,
    Returned = 5,
    Exchanged = 6,
}

export class OrderProduct implements IOrderProduct {
    productId?: string | undefined;
    quantity?: number;
    totalPrice?: number;
    data?: ProductData | undefined;
    model?: ProductModelData | undefined;

    constructor(data?: IOrderProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.totalPrice = _data["totalPrice"];
            this.data = _data["data"] ? ProductData.fromJS(_data["data"]) : <any>undefined;
            this.model = _data["model"] ? ProductModelData.fromJS(_data["model"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderProduct {
        data = typeof data === 'object' ? data : {};
        let result = new OrderProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["totalPrice"] = this.totalPrice;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderProduct {
    productId?: string | undefined;
    quantity?: number;
    totalPrice?: number;
    data?: ProductData | undefined;
    model?: ProductModelData | undefined;
}

export class ProductData implements IProductData {
    code?: string | undefined;
    type?: string | undefined;
    size?: number | undefined;
    inventory?: number;
    images?: string[] | undefined;

    constructor(data?: IProductData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.type = _data["type"];
            this.size = _data["size"];
            this.inventory = _data["inventory"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductData {
        data = typeof data === 'object' ? data : {};
        let result = new ProductData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["type"] = this.type;
        data["size"] = this.size;
        data["inventory"] = this.inventory;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        return data;
    }
}

export interface IProductData {
    code?: string | undefined;
    type?: string | undefined;
    size?: number | undefined;
    inventory?: number;
    images?: string[] | undefined;
}

export class ProductModelData implements IProductModelData {
    name?: string | undefined;
    code?: string | undefined;
    costPrice?: number;
    priceIncurred?: number;
    price?: number;
    salePrice?: number;

    constructor(data?: IProductModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.costPrice = _data["costPrice"];
            this.priceIncurred = _data["priceIncurred"];
            this.price = _data["price"];
            this.salePrice = _data["salePrice"];
        }
    }

    static fromJS(data: any): ProductModelData {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["costPrice"] = this.costPrice;
        data["priceIncurred"] = this.priceIncurred;
        data["price"] = this.price;
        data["salePrice"] = this.salePrice;
        return data;
    }
}

export interface IProductModelData {
    name?: string | undefined;
    code?: string | undefined;
    costPrice?: number;
    priceIncurred?: number;
    price?: number;
    salePrice?: number;
}

export class PagedListVmOfOrderOptionDto implements IPagedListVmOfOrderOptionDto {
    data?: OrderOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfOrderOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfOrderOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfOrderOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfOrderOptionDto {
    data?: OrderOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class OrderOptionDto extends OptionModelOfString implements IOrderOptionDto {

    constructor(data?: IOrderOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): OrderOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IOrderOptionDto extends IOptionModelOfString {
}

export class OrderDetailVm implements IOrderDetailVm {
    id?: string | undefined;
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;

    constructor(data?: IOrderDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? OrderData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(OrderProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrderDetailVm {
    id?: string | undefined;
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;
}

export class CreateOrderCommand implements ICreateOrderCommand {
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? OrderData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(OrderProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateOrderCommand {
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;
}

export class UpdateOrderCommand implements IUpdateOrderCommand {
    id?: string | undefined;
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;

    constructor(data?: IUpdateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? OrderData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(OrderProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateOrderCommand {
    id?: string | undefined;
    data?: OrderData | undefined;
    products?: OrderProduct[] | undefined;
}

export class PagedListVmOfPermissionDto implements IPagedListVmOfPermissionDto {
    data?: PermissionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PermissionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfPermissionDto {
    data?: PermissionDto[] | undefined;
    page?: PageModel | undefined;
}

export class PermissionOfUserDto implements IPermissionOfUserDto {
    id?: string | undefined;
    data?: PermissionData | undefined;
    groupPermissionData?: GroupPermissionData | undefined;
    direction?: string | undefined;

    constructor(data?: IPermissionOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? PermissionData.fromJS(_data["data"]) : <any>undefined;
            this.groupPermissionData = _data["groupPermissionData"] ? GroupPermissionData.fromJS(_data["groupPermissionData"]) : <any>undefined;
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): PermissionOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["groupPermissionData"] = this.groupPermissionData ? this.groupPermissionData.toJSON() : <any>undefined;
        data["direction"] = this.direction;
        return data;
    }
}

export interface IPermissionOfUserDto {
    id?: string | undefined;
    data?: PermissionData | undefined;
    groupPermissionData?: GroupPermissionData | undefined;
    direction?: string | undefined;
}

export class GetPermissionsOfUserQuery implements IGetPermissionsOfUserQuery {

    constructor(data?: IGetPermissionsOfUserQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetPermissionsOfUserQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionsOfUserQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetPermissionsOfUserQuery {
}

export class GroupPermissionOfUserDto implements IGroupPermissionOfUserDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: PermissionOfUser[] | undefined;

    constructor(data?: IGroupPermissionOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionOfUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupPermissionOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermissionOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupPermissionOfUserDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: PermissionOfUser[] | undefined;
}

export class PermissionOfUser implements IPermissionOfUser {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPermissionOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IPermissionOfUser {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
}

export class PermissionDetailVm implements IPermissionDetailVm {
    id?: string | undefined;
    groupId?: string | undefined;
    data?: PermissionData | undefined;
    listOfActionId?: string[] | undefined;

    constructor(data?: IPermissionDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.data = _data["data"] ? PermissionData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["listOfActionId"])) {
                this.listOfActionId = [] as any;
                for (let item of _data["listOfActionId"])
                    this.listOfActionId!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.listOfActionId)) {
            data["listOfActionId"] = [];
            for (let item of this.listOfActionId)
                data["listOfActionId"].push(item);
        }
        return data;
    }
}

export interface IPermissionDetailVm {
    id?: string | undefined;
    groupId?: string | undefined;
    data?: PermissionData | undefined;
    listOfActionId?: string[] | undefined;
}

export class UpsertPermissionCommand implements IUpsertPermissionCommand {
    id?: string | undefined;
    groupId?: string | undefined;
    data?: PermissionData | undefined;
    listOfActionId?: string[] | undefined;

    constructor(data?: IUpsertPermissionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.data = _data["data"] ? PermissionData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["listOfActionId"])) {
                this.listOfActionId = [] as any;
                for (let item of _data["listOfActionId"])
                    this.listOfActionId!.push(item);
            }
        }
    }

    static fromJS(data: any): UpsertPermissionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertPermissionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.listOfActionId)) {
            data["listOfActionId"] = [];
            for (let item of this.listOfActionId)
                data["listOfActionId"].push(item);
        }
        return data;
    }
}

export interface IUpsertPermissionCommand {
    id?: string | undefined;
    groupId?: string | undefined;
    data?: PermissionData | undefined;
    listOfActionId?: string[] | undefined;
}

export class PagedListVmOfProductCategoryDto implements IPagedListVmOfProductCategoryDto {
    data?: ProductCategoryDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductCategoryDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfProductCategoryDto {
    data?: ProductCategoryDto[] | undefined;
    page?: PageModel | undefined;
}

export class ProductCategoryDto extends AuditableEntity implements IProductCategoryDto {
    data?: ProductCategoryData | undefined;

    constructor(data?: IProductCategoryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ProductCategoryData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProductCategoryDto extends IAuditableEntity {
    data?: ProductCategoryData | undefined;
}

export class ProductCategoryData implements IProductCategoryData {
    name?: string | undefined;
    key?: string | undefined;

    constructor(data?: IProductCategoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): ProductCategoryData {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        return data;
    }
}

export interface IProductCategoryData {
    name?: string | undefined;
    key?: string | undefined;
}

export class PagedListVmOfProductCategoryOptionDto implements IPagedListVmOfProductCategoryOptionDto {
    data?: ProductCategoryOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfProductCategoryOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductCategoryOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfProductCategoryOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfProductCategoryOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfProductCategoryOptionDto {
    data?: ProductCategoryOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class ProductCategoryOptionDto extends OptionModelOfString implements IProductCategoryOptionDto {

    constructor(data?: IProductCategoryOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ProductCategoryOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductCategoryOptionDto extends IOptionModelOfString {
}

export class ProductCategoryDetailVm implements IProductCategoryDetailVm {
    id?: string | undefined;
    data?: ProductCategoryData | undefined;

    constructor(data?: IProductCategoryDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ProductCategoryData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategoryDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductCategoryDetailVm {
    id?: string | undefined;
    data?: ProductCategoryData | undefined;
}

export class CreateProductCategoryCommand implements ICreateProductCategoryCommand {
    data?: ProductCategoryData | undefined;

    constructor(data?: ICreateProductCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ProductCategoryData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateProductCategoryCommand {
    data?: ProductCategoryData | undefined;
}

export class UpdateProductCategoryCommand implements IUpdateProductCategoryCommand {
    id?: string | undefined;
    data?: ProductCategoryData | undefined;

    constructor(data?: IUpdateProductCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ProductCategoryData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProductCategoryCommand {
    id?: string | undefined;
    data?: ProductCategoryData | undefined;
}

export class PagedListVmOfProductModelDto implements IPagedListVmOfProductModelDto {
    data?: ProductModelDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfProductModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductModelDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfProductModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfProductModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfProductModelDto {
    data?: ProductModelDto[] | undefined;
    page?: PageModel | undefined;
}

export class ProductModelDto extends AuditableEntity implements IProductModelDto {
    data?: ProductModelData | undefined;
    products?: Product[] | undefined;

    constructor(data?: IProductModelDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ProductModelData.fromJS(_data["data"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProductModelDto extends IAuditableEntity {
    data?: ProductModelData | undefined;
    products?: Product[] | undefined;
}

export class Product extends AuditableEntity implements IProduct {
    modelId?: string | undefined;
    data?: ProductData | undefined;
    model?: ProductModel | undefined;

    constructor(data?: IProduct) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.modelId = _data["modelId"];
            this.data = _data["data"] ? ProductData.fromJS(_data["data"]) : <any>undefined;
            this.model = _data["model"] ? ProductModel.fromJS(_data["model"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProduct extends IAuditableEntity {
    modelId?: string | undefined;
    data?: ProductData | undefined;
    model?: ProductModel | undefined;
}

export class ProductModel extends AuditableEntity implements IProductModel {
    categoryId?: string | undefined;
    data?: ProductModelData | undefined;
    category?: ProductCategory | undefined;
    products?: Product[] | undefined;

    constructor(data?: IProductModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.data = _data["data"] ? ProductModelData.fromJS(_data["data"]) : <any>undefined;
            this.category = _data["category"] ? ProductCategory.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProductModel extends IAuditableEntity {
    categoryId?: string | undefined;
    data?: ProductModelData | undefined;
    category?: ProductCategory | undefined;
    products?: Product[] | undefined;
}

export class ProductCategory extends AuditableEntity implements IProductCategory {
    data?: ProductCategoryData | undefined;

    constructor(data?: IProductCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ProductCategoryData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProductCategory extends IAuditableEntity {
    data?: ProductCategoryData | undefined;
}

export class PagedListVmOfProductModelOptionDto implements IPagedListVmOfProductModelOptionDto {
    data?: ProductModelOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfProductModelOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductModelOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfProductModelOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfProductModelOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfProductModelOptionDto {
    data?: ProductModelOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class ProductModelOptionDto extends OptionModelOfString implements IProductModelOptionDto {

    constructor(data?: IProductModelOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ProductModelOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModelOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductModelOptionDto extends IOptionModelOfString {
}

export class ProductModelDetailVm implements IProductModelDetailVm {
    id?: string | undefined;
    data?: ProductModelData | undefined;

    constructor(data?: IProductModelDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"] ? ProductModelData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductModelDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModelDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductModelDetailVm {
    id?: string | undefined;
    data?: ProductModelData | undefined;
}

export class CreateProductModelCommand implements ICreateProductModelCommand {
    categoryId?: string | undefined;
    data?: ProductModelData | undefined;

    constructor(data?: ICreateProductModelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.data = _data["data"] ? ProductModelData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductModelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductModelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateProductModelCommand {
    categoryId?: string | undefined;
    data?: ProductModelData | undefined;
}

export class UpdateProductModelCommand implements IUpdateProductModelCommand {
    id?: string | undefined;
    categoryId?: string | undefined;
    data?: ProductModelData | undefined;

    constructor(data?: IUpdateProductModelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.data = _data["data"] ? ProductModelData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductModelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductModelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProductModelCommand {
    id?: string | undefined;
    categoryId?: string | undefined;
    data?: ProductModelData | undefined;
}

export class PagedListVmOfProductDto implements IPagedListVmOfProductDto {
    data?: ProductDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfProductDto {
    data?: ProductDto[] | undefined;
    page?: PageModel | undefined;
}

export class ProductDto extends AuditableEntity implements IProductDto {
    data?: ProductData | undefined;
    model?: ProductModelData | undefined;

    constructor(data?: IProductDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? ProductData.fromJS(_data["data"]) : <any>undefined;
            this.model = _data["model"] ? ProductModelData.fromJS(_data["model"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IProductDto extends IAuditableEntity {
    data?: ProductData | undefined;
    model?: ProductModelData | undefined;
}

export class PagedListVmOfProductOptionDto implements IPagedListVmOfProductOptionDto {
    data?: ProductOptionDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfProductOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductOptionDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfProductOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfProductOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfProductOptionDto {
    data?: ProductOptionDto[] | undefined;
    page?: PageModel | undefined;
}

export class ProductOptionDto extends OptionModelOfString implements IProductOptionDto {

    constructor(data?: IProductOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ProductOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IProductOptionDto extends IOptionModelOfString {
}

export class ProductDetailVm implements IProductDetailVm {
    id?: string | undefined;
    modelId?: string | undefined;
    data?: ProductData | undefined;
    model?: ProductModelData | undefined;

    constructor(data?: IProductDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.modelId = _data["modelId"];
            this.data = _data["data"] ? ProductData.fromJS(_data["data"]) : <any>undefined;
            this.model = _data["model"] ? ProductModelData.fromJS(_data["model"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modelId"] = this.modelId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductDetailVm {
    id?: string | undefined;
    modelId?: string | undefined;
    data?: ProductData | undefined;
    model?: ProductModelData | undefined;
}

export class CreateProductCommand implements ICreateProductCommand {
    modelId?: string | undefined;
    data?: ProductData | undefined;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.modelId = _data["modelId"];
            this.data = _data["data"] ? ProductData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modelId"] = this.modelId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateProductCommand {
    modelId?: string | undefined;
    data?: ProductData | undefined;
}

export class UpdateProductCommand implements IUpdateProductCommand {
    id?: string | undefined;
    modelId?: string | undefined;
    data?: ProductData | undefined;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.modelId = _data["modelId"];
            this.data = _data["data"] ? ProductData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modelId"] = this.modelId;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProductCommand {
    id?: string | undefined;
    modelId?: string | undefined;
    data?: ProductData | undefined;
}

export class PagedListVmOfRoleDto implements IPagedListVmOfRoleDto {
    data?: RoleDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfRoleDto {
    data?: RoleDto[] | undefined;
    page?: PageModel | undefined;
}

export class RoleDto implements IRoleDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRoleDto {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;
    auditData?: AuditableModel | undefined;
}

export class RoleOptionDto extends OptionModel implements IRoleOptionDto {

    constructor(data?: IRoleOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RoleOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRoleOptionDto extends IOptionModel {
}

export class RoleDetailVm implements IRoleDetailVm {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IRoleDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRoleDetailVm {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;
    auditData?: AuditableModel | undefined;
}

export class CreateRoleCommand implements ICreateRoleCommand {
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: ICreateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface ICreateRoleCommand {
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IUpdateRoleCommand {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    permissions?: string[] | undefined;
}

export class PagedListVmOfTempTrashDto implements IPagedListVmOfTempTrashDto {
    data?: TempTrashDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfTempTrashDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TempTrashDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfTempTrashDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfTempTrashDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfTempTrashDto {
    data?: TempTrashDto[] | undefined;
    page?: PageModel | undefined;
}

export class TempTrashDto implements ITempTrashDto {
    id?: string | undefined;
    entityName?: string | undefined;
    data?: any | undefined;
    auditData?: BaseAuditableModel | undefined;

    constructor(data?: ITempTrashDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityName = _data["entityName"];
            this.data = _data["data"];
            this.auditData = _data["auditData"] ? BaseAuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TempTrashDto {
        data = typeof data === 'object' ? data : {};
        let result = new TempTrashDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityName"] = this.entityName;
        data["data"] = this.data;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITempTrashDto {
    id?: string | undefined;
    entityName?: string | undefined;
    data?: any | undefined;
    auditData?: BaseAuditableModel | undefined;
}

export class RestoreTempTrashCommand implements IRestoreTempTrashCommand {
    id?: string | undefined;

    constructor(data?: IRestoreTempTrashCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RestoreTempTrashCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RestoreTempTrashCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IRestoreTempTrashCommand {
    id?: string | undefined;
}

export class PagedListVmOfUserDto implements IPagedListVmOfUserDto {
    data?: UserDto[] | undefined;
    page?: PageModel | undefined;

    constructor(data?: IPagedListVmOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            this.page = _data["page"] ? PageModel.fromJS(_data["page"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedListVmOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListVmOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page ? this.page.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPagedListVmOfUserDto {
    data?: UserDto[] | undefined;
    page?: PageModel | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profile?: UserProfile | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    profile?: UserProfile | undefined;
    auditData?: AuditableModel | undefined;
}

export class UserOptionDto extends OptionModel implements IUserOptionDto {

    constructor(data?: IUserOptionDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UserOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUserOptionDto extends IOptionModel {
}

export class UserDetailVm implements IUserDetailVm {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    roles?: string[] | undefined;
    profile?: UserProfile | undefined;
    auditData?: AuditableModel | undefined;

    constructor(data?: IUserDetailVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
            this.auditData = _data["auditData"] ? AuditableModel.fromJS(_data["auditData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDetailVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["auditData"] = this.auditData ? this.auditData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserDetailVm {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    roles?: string[] | undefined;
    profile?: UserProfile | undefined;
    auditData?: AuditableModel | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    email?: string | undefined;
    userName?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    roles?: string[] | undefined;
    profile?: UserProfile | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateUserCommand {
    email?: string | undefined;
    userName?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    roles?: string[] | undefined;
    profile?: UserProfile | undefined;
}

export class EntityModelOfString implements IEntityModelOfString {
    id?: string | undefined;

    constructor(data?: IEntityModelOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityModelOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityModelOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityModelOfString {
    id?: string | undefined;
}

export class UpdateUserCommand extends EntityModelOfString implements IUpdateUserCommand {
    email?: string | undefined;
    userName?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    roles?: string[] | undefined;
    profile?: UserProfile | undefined;

    constructor(data?: IUpdateUserCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateUserCommand extends IEntityModelOfString {
    email?: string | undefined;
    userName?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    roles?: string[] | undefined;
    profile?: UserProfile | undefined;
}

export class UpdateUserRolesCommand extends EntityModelOfString implements IUpdateUserRolesCommand {
    roles?: string[] | undefined;

    constructor(data?: IUpdateUserRolesCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserRolesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRolesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateUserRolesCommand extends IEntityModelOfString {
    roles?: string[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}